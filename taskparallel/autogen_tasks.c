/*
   THIS FILE WILL BE AUTOGENERATED
*/
#include <stdlib.h>
#include <pthread.h>
#include <semaphore.h>
#include "task.h"
#include "helper.h"

int id;
int visited[100];
int sum = 0;
list_t* myList;
node_t* p;

// Semaphores and data to send messages from t1 to t2/t3
sem_t t1_to_t1_sem;
node_t *t1_to_t1_p;
sem_t t1_to_t2_sem;
node_t *t1_to_t2_p;
sem_t t1_to_t3_sem;
node_t *t1_to_t3_p;

// Function prototypes
extern void print_structure(list_t *);
extern node_t* create_node(int id, int flag, int value);
extern void add_to_outer_list(list_t* list, node_t* new_node);
extern node_t* generate_inner_list(int length);
extern int rand_range(int min, int max);

void autogen_initialize() {


    srand(time(NULL)); // Seed the random number generator

    myList = (list_t*)malloc(sizeof(list_t));
    myList->head = NULL;

    // Silly code to make some workload
    int outerListSize = 15; // For demonstration, let's have 5 nodes in the outer list
    for (int i = 0; i < outerListSize; i++) {
        int flag = rand() % 2; // Random flag value (0 or 1)
        int value = rand() % 101; // Random value between 0 and 100
        node_t* new_node = create_node(i, flag, value);
        new_node->inner_list = generate_inner_list(rand_range(1, 5)); // Inner list of random length 1-5
        add_to_outer_list(myList, new_node);
    }
    print_structure(myList);

    // initialize the communication
    t1_to_t1_p = myList->head;
    sem_init(&t1_to_t1_sem, 0, 0);
    sem_init(&t1_to_t2_sem, 0, 0);
    sem_init(&t1_to_t3_sem, 0, 0);

    return;
}




int _loopiter = 0;
void task1(void *arg) {
    while(1) {
        // Collect my inputs
        printf("task1: waiting for input from myself\n");
        sem_wait(&t1_to_t1_sem);
        node_t* p = t1_to_t1_p;

        if(p==NULL) {
            printf("task1: reached null\n");
            return;
        }
        printf("task1: now at outer node %d\n", p->id);
        id = p->id;
        if(!visited[id])
        visited[id] = 1;
        if(_loopiter++%2==0) {
            printf("task1: create unit of work for task 2: p=%ld\n", (long int)p);
            t1_to_t2_p = p;
            sem_post(&t1_to_t2_sem);
        } else {
            printf("task1: create unit of work for task 2: p=%ld\n", (long int)p);
            t1_to_t2_p = p;
            sem_post(&t1_to_t2_sem);
        }
        // Send message to next iteration of this task
        t1_to_t1_p = p->next;
        sem_post(&t1_to_t1_p);
    }
    return;
}
void task2(void *arg) {
    while(1) {
        // Wait for my inputs from t1
        printf("task2: waiting for input.\n");
        sem_wait(&t1_to_t2_sem);
        node_t* p = t1_to_t2_p;

        printf("task2: starting to process unit of work p=%ld\n", (long int)p);
        node_t* q = p->inner_list;
        while(q!=NULL && !q->flag) {
            q = q->next;
        }
        if(q != NULL) sum += p->value;
    }
}
void task3(void *arg) {
    while(1) {
        // Wait for my inputs from t1
        printf("task3: waiting for input.\n");
        sem_wait(&t1_to_t3_sem);
        node_t* p = t1_to_t3_p;

        printf("task3: starting to process unit of work p=%ld\n", (long int)p);
        node_t* q = p->inner_list;
        while(q!=NULL && !q->flag) {
            q = q->next;
        }
        if(q != NULL) sum += p->value;
    }
}

int autogen_taskcount() { return 3; }

task_t* autogen_loadtask(int i) {
    task_t* t = malloc(sizeof(task_t));
    t->id = i;
    switch (i) {
        case 1:
        t->function = task1;
        t->data = (void*)(intptr_t)i; /* just an int for now */
        break;
        case 2:
        t->function = task2;
        t->data = (void*)(intptr_t)i; /* just an int for now */
        break;
        case 3:
        t->function = task3;
        t->data = (void*)(intptr_t)i; /* just an int for now */
        break;
    }
    return t;
}